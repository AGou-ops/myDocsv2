(window.webpackJsonp=window.webpackJsonp||[]).push([[237],{869:function(v,_,t){"use strict";t.r(_);var s=t(6),r=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"lvs-调度算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lvs-调度算法"}},[v._v("#")]),v._v(" LVS 调度算法")]),v._v(" "),t("h3",{attrs:{id:"静态调度算法-仅根据算法本身进行调度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#静态调度算法-仅根据算法本身进行调度"}},[v._v("#")]),v._v(" 静态调度算法(仅根据算法本身进行调度)：**")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("RR：")]),v._v(" 轮询调度（Round Robin）")])]),v._v(" "),t("p",[v._v("调度器通过“轮询”调度算法将外部请求按顺序轮流分配到集群中的真实服务器上，它均等地对待每一台服务器，而不管服务器上实际的连接数和系统负载。"),t("strong",[v._v("属于大锅饭调度。")])]),v._v(" "),t("p",[v._v("此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。")]),v._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[t("strong",[v._v("WRR:")]),v._v(" 加权轮询（Weighted Round Robin）")])]),v._v(" "),t("p",[v._v("根据真实服务器的不同处理能力来调度访问请求。这样可以保证处理能力强的服务器能处理更多的访问流量。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。"),t("strong",[v._v("带权重的大锅饭调度。")])]),v._v(" "),t("p",[v._v("此种均衡算法能确保高性能的服务器得到更多的使用率，避免低性能的服务器负载过重。")]),v._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[t("strong",[v._v("SH:")]),v._v(" 源地址哈希（Source Hashing）")])]),v._v(" "),t("p",[v._v("根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器。基于client地址的来源区分。实现session sticky。")]),v._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[t("strong",[v._v("DH:")]),v._v(" 目标地址哈希（Destination Hashing）")])]),v._v(" "),t("p",[v._v("根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。")]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"动态调度算法-根据每rs当前的负载状态及调度算法进行调度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动态调度算法-根据每rs当前的负载状态及调度算法进行调度"}},[v._v("#")]),v._v(" "),t("strong",[v._v("动态调度算法(根据每RS当前的负载状态及调度算法进行调度)：")])]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("LC:")]),v._v(" 最少链接（Least Connections）")])]),v._v(" "),t("p",[v._v("动态地将网络请求调度到已建立的链接数最少的服务器上。如果集群系统的真实服务器具有相近的系统性能，采用“最小连接”调度算法可以较好地均衡负载。"),t("strong",[v._v("谁不干活就给谁分配")])]),v._v(" "),t("p",[v._v("此种均衡算法适合长连接处理的请求服务，如FTP。")]),v._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[t("strong",[v._v("WLC：")]),v._v(" 加权最少链接（Weighted Least Connections）")])]),v._v(" "),t("p",[v._v("**默认调度方法。**在集群系统中的服务器性能差异较大的情况下，调度器采用此调度算法优化负载均衡性能，具有较高权值的服务器将承受较大比例的活动连接负载。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。**带权重的谁不干活就给谁分配，**机器配置好的权重高")]),v._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[t("strong",[v._v("SED:")]),v._v(" 初始连接高权重优先（Shortest Expected Delay Scheduling SED）")])]),v._v(" "),t("p",[v._v("基于wlc算法。一个新的初始链接的时候，优先分配权重高的服务器。缺陷：当权重过大的时候，会导致空闲服务器一直处于无连接状态")]),v._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[t("strong",[v._v("NQ:")]),v._v(" 最少队列调度（Never Queue Scheduling NQ）")])]),v._v(" "),t("p",[v._v("第一轮均匀分配，后续SED。无需队列。如果有台 RealServer的连接数＝0 就直接分配过去，不需要再进行sed运算，保证不会有一个主机很空闲。不考虑非活动连接，才用NQ，SED要考虑活动状态连接，对于DNS的UDP不需要考虑非活动连接，而httpd的处于保持状态的服务就需要考虑非活动连接给服务器的压力。")]),v._v(" "),t("ol",{attrs:{start:"5"}},[t("li",[t("strong",[v._v("LBLC:")]),v._v(" 基于局部性的最少链接（Locality-Based Least Connections）")])]),v._v(" "),t("p",[v._v("动态的DH算法，使用场景：根据负载状态实现正向代理")]),v._v(" "),t("p",[v._v("针对目标IP地址的负载均衡，目前主要用于Cache集群系统。该算法根据请求的目标IP地址找出该目标IP地址最近使用的服务器，若该服务器是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则用“最少链接” 的原则选出一个可用的服务器，将请求发送到该服务器。基于本地的最小连接。把请求传递到负载小的服务器上")]),v._v(" "),t("ol",{attrs:{start:"6"}},[t("li",[t("strong",[v._v("LBLCR:")]),v._v(" 带复制的基于局部性最少链接（Locality-Based Least Connections with Replication）")])]),v._v(" "),t("p",[v._v("带复制功能的LBLC,"),t("strong",[v._v("解决LBLC负载不均衡问题")]),v._v("，从负载重的复制到负载轻的RS。")]),v._v(" "),t("p",[v._v("针对目标IP地址的负载均衡，目前主要用于Cache集群系统。它与LBLC算法的不同之处是它要维护从一个目标 IP地址到一组服务器的映射，而LBLC算法维护从一个目标IP地址到一台服务器的映射。该算法根据请求的目标IP地址找出该目标IP地址对应的服务器组，按“最小连接”原则从服务器组中选出一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载，则按“最少链接”原则从这个集群中选出一台服务器，将该服务器加入到服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。")]),v._v(" "),t("p",[v._v("某页面缓存在服务器A上，被访问次数极高，而其他缓存服务器负载较低，监视是否访问同一页面，如果是访问同一页面则把请求分到其他服务器。")]),v._v(" "),t("p",[t("strong",[v._v("下面列举一些针对不同环境个人采用的模式和调度算法：")])]),v._v(" "),t("p",[t("strong",[v._v("1.")]),v._v(" 如果后端服务器的"),t("strong",[v._v("配置相同")]),v._v("，而且"),t("strong",[v._v("台数不多")]),v._v("的话")]),v._v(" "),t("p",[v._v("可以使用LVS三种模式中的任意一种，调度算法可以是RR")]),v._v(" "),t("p",[t("strong",[v._v("2.")]),v._v(" 如果后端服务器的"),t("strong",[v._v("配置相同")]),v._v("，但是"),t("strong",[v._v("台数很多")]),v._v("的话")]),v._v(" "),t("p",[v._v("可以使用LVS-DR或者LVS-TUN模式，调度算法可以是RR")]),v._v(" "),t("p",[t("strong",[v._v("3.")]),v._v(" 如果后端服务器的"),t("strong",[v._v("配置相同")]),v._v("，但是"),t("strong",[v._v("台数很多")])]),v._v(" "),t("p",[v._v("而且服务器分布"),t("strong",[v._v("在不同的局域网")]),v._v("中，那么使用LVS-TUN模式，调度算法可以是RR")]),v._v(" "),t("p",[t("strong",[v._v("4.")]),v._v(" 如果后端服务器的"),t("strong",[v._v("配置不同")]),v._v("，而且"),t("strong",[v._v("台数不多")]),v._v("的话")]),v._v(" "),t("p",[v._v("可以使用LVS三种模式中的任意一种，调度算法可以是WRR")]),v._v(" "),t("p",[t("strong",[v._v("5.")]),v._v(" 如果后端服务器的"),t("strong",[v._v("配置不同")]),v._v("，但是"),t("strong",[v._v("台数很多")]),v._v("的话")]),v._v(" "),t("p",[v._v("可以使用LVS-DR或者LVS-TUN模式，调度算法可以是WRR")]),v._v(" "),t("p",[t("strong",[v._v("6.")]),v._v(" 如果后端服务器的"),t("strong",[v._v("配置不同")]),v._v("，但是"),t("strong",[v._v("台数很多")])]),v._v(" "),t("p",[v._v("而且服务器分布"),t("strong",[v._v("在不同的局域网")]),v._v("中，那么使用LVS-TUN模式，调度算法可以是WRR")]),v._v(" "),t("p",[t("strong",[v._v("7.")]),v._v(" 如果后端服务器使用了"),t("strong",[v._v("cache系统")])]),v._v(" "),t("p",[v._v("可以使用LVS-DR或者LVS-TUN模式，调度算法可以是LBLC或者LBLCR")]),v._v(" "),t("p",[t("strong",[v._v("8.")]),v._v(" 如果后端服务器使用了"),t("strong",[v._v("cache系统")]),v._v("，"),t("strong",[v._v("且架构体系庞大")]),v._v("，使用LVS-TUN模式，调度算法是LBLCR")]),v._v(" "),t("p",[t("strong",[v._v("9.")]),v._v(" 如果后端服务器为集群且"),t("strong",[v._v("性能差异大")]),v._v("，使用LVS-DR或者LVS-TUN模式，调度算法采用WLC")]),v._v(" "),t("p",[t("strong",[v._v("10.")]),v._v(" 如果后端服务器为集群且"),t("strong",[v._v("性能差异不大")]),v._v("，使用lvs/dr或者LVS-TUN模式，调度算法采用LC")])])}),[],!1,null,null,null);_.default=r.exports}}]);